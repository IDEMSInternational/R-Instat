' Instat+R
' Copyright (C) 2015
'
' This program is free software: you can redistribute it and/or modify
' it under the terms of the GNU General Public License as published by
' the Free Software Foundation, either version 3 of the License, or
' (at your option) any later version.
'
' This program is distributed in the hope that it will be useful,
' but WITHOUT ANY WARRANTY; without even the implied warranty of
' MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
' GNU General Public License for more details.
'
' You should have received a copy of the GNU General Public License k
' along with this program.  If not, see <http://www.gnu.org/licenses/>.
Public Class BlockReader
    'This class enables to take a block of R-Instat generated R Script, and translate it into a strComment and a list of RParameters containing the full description of the different R Commands in the R Script. 
    'Task: would need to identify the main R command, the assignTo methods and the secondary R commands. 'Warning, blocks are for the moment blocks of RunScript. So secondary R Commands are not in the same block as main R command. Need to work on this from different points of view: RSyntax, RunScript, Output and Block Selection.
    'Task: Still need to identify the main R Command and figure out the parameters in SetAssignTo of that one depending on the different lines of code generated by ToScript.
    'Task: comment the methods when polished...
    '[17:09:37] François Renaud: Also for the moment secondary and main R commands generated within a dialogue are in separate blocks, but this needs to be addressed from the point of view of RSyntax, Runscript, Output and BlockSelector before BlockReader get's edited.
    '[1711:29] Danny Parsons: yes that will all be In RSyntax
    '[17:11:50] Danny Parsons: although we will Then need a way To remove output from a block As there will be output between commands
    '[17:20:11] François Renaud: aiaa, yes, that's true. Ok, I m thinking, maybe the easiest is to have different layers, runscript blocks and dialogue blocks. Output's can be padded with another type of symbol as vbcrlf or we could even imagine to have signatures provided by each dialogue... this would facilitate the repopulation of the dialogue when clicking on a block.

    Private strComment As String 'The comment that is part of the block. 'Warning: only one comment per bloc for now... will need to go over this when secondary R-commands are taken in the same block.
    Private lstRCommands As List(Of RParameter) 'The list of RParameters that store the information about the RCommands. Still contains bIsFunction and bIsOperator.
    Public Property Comment() As String
        Get
            Return strComment
        End Get
        Set(strTempComment As String)
            strComment = strTempComment
        End Set
    End Property
    Public Property RCommands() As List(Of RParameter)
        Get
            Return lstRCommands
        End Get
        Set(lstTempRCommands As List(Of RParameter))
            lstRCommands = lstTempRCommands
        End Set
    End Property

    Public Sub New()
        lstRCommands = New List(Of RParameter)
    End Sub
    'Public Sub SetBlockText(strTempBlockText As String)
    '    strBlockText = strTempBlockText
    'End Sub
    Public Sub ReadBlock(strBlockText As String)
        Dim lstLines As String()
        lstLines = strBlockText.Split(vbCrLf)
        If lstRCommands Is Nothing Then
            lstRCommands = New List(Of RParameter)
        End If
        For i As Integer = 0 To lstLines.Count - 1
            If lstLines(i).First = "#" Then
                Comment = lstLines(i)
            Else
                lstRCommands.Add(ReadRCommand(lstLines(i)))
            End If
        Next
        'Task: Still need to link the different blocks when possible... using the revert of ToScript to see what are the settings in the main RCommand, depending on the assignto R methods that have been called. Or is this done on the dialogues ? To investigate.
    End Sub

    Public Function ReadRCommand(strRCommand As String) As RParameter
        Dim clsReturnRParameter As New RParameter
        Dim iNumberOfUnclosedBrackets As Integer
        Dim chrSeparator As Char
        Dim bFirstOpParam As Boolean = False
        Dim lstAssignToCheck As List(Of String)
        Dim lstParameterStrings As List(Of String)
        Dim strAssignTo As String

        'This is the read through method
        For Each chrSymbol As Char In strRCommand
            If chrSymbol = "(" Then
                iNumberOfUnclosedBrackets = iNumberOfUnclosedBrackets + 1
            ElseIf chrSymbol = ")" Then
                iNumberOfUnclosedBrackets = iNumberOfUnclosedBrackets - 1
            ElseIf iNumberOfUnclosedBrackets = 0 Then
                'Do things
            End If
        Next
        lstAssignToCheck = SplitSmart(strRCommand, "<-")
        If lstAssignToCheck.Count = 2 Then
            strAssignTo = lstAssignToCheck(0)
            strRCommand = lstAssignToCheck(1)
        ElseIf lstAssignToCheck.Count = 1 Then
            strAssignTo = Nothing
        Else
            'message
        End If
        'This identifies if the RCommand is an RFunction or ROperator, set's the RCommand, edits strRCommand if RFunction case, and returns the relevant separator for arguments
        chrSeparator = IdentifyCommand(strRCommand, clsReturnRParameter)
        'Each argument is isolated adn then all of them are assimilated by the RCodeStructure.
        lstParameterStrings = SplitSmart(strRCommand, chrSeparator)
        For Each strString As String In lstParameterStrings
            'AssimilateParameter(clsReturnRParameter.clsArgument) 'for when RParameters has merely a clsCodeStructure as field. Would then delete the following If statement
            If clsReturnRParameter.bIsFunction Then
                AssimilateParameter(strString, clsReturnRParameter.clsArgumentFunction)
            Else
                AssimilateParameter(strString, clsReturnRParameter.clsArgumentOperator)
            End If
        Next
        If strAssignTo IsNot Nothing Then
            'clsReturnRParameter.clsArgument.SetAssignTo(strAssignTo) 'need to use ReadBlock to fuly SetAssignTo as it requires reading different RCommands and use the ToScript reverse to deduce settings of SetAssignTo. This at least enables to store the relevant value of AssignTo.
        End If
        Return clsReturnRParameter
    End Function

    Private Function SplitSmart(strToSplit As String, strSeparator As String) As List(Of String)
        'This function takes a string containing an RCommand, and a separator. It then acts as the function Split, but ignoring instances of the separator that occur within closed brackets.
        Dim strSymbol As String
        Dim lstIndices As New List(Of Integer)
        Dim lstReturn As New List(Of String)

        'Getting the list of indices at which the separator starts, skipping potential occurences of the separator inside a closed bracket.
        For iIndex As Integer = 0 To strToSplit.Count - strSeparator.Length
            strSymbol = strToSplit.Substring(iIndex, iIndex + strSeparator.Length - 1)
            If strSymbol.First = "(" Then
                iIndex = FindMatchingBracket(strToSplit, iIndex)
                If iIndex <> -1 Then
                    Continue For
                Else
                    'message
                    Exit For
                End If
            ElseIf strSymbol = strSeparator Then
                lstIndices.Add(iIndex)
            End If
        Next
        'Trimming the string by the separator, using the identified indices if there are some.
        Dim iLastIndex As Integer = -strSeparator.Length
        For Each iIndex In lstIndices
            lstReturn.Add(strToSplit.Substring(iLastIndex + strSeparator.Length, iIndex - 1))
            iLastIndex = iIndex
        Next
        'Dealing with the leftover piece of string after the last index.
        If lstIndices.Count > 0 Then
            If lstIndices.Last + strSeparator.Length < strToSplit.Length Then
                lstReturn.Add(strToSplit.Substring(lstIndices.Last + strSeparator.Length))
            Else
                'message
            End If
        Else
            lstReturn.Add(strToSplit)
        End If

        Return lstReturn
    End Function
    Private Function FindMatchingBracket(strToRead As String, iIndex As Integer) As Integer
        'This function takes as input a string and the index of an open bracket. It returns the index of the matching bracket if it exists, otherwise -1.
        Dim iNumberOfUnclosedBrackets As Integer
        Dim chrSymbol As Char

        iNumberOfUnclosedBrackets = 1
        While (iNumberOfUnclosedBrackets > 0 AndAlso iIndex + 1 < strToRead.Count)
            iIndex = iIndex + 1
            chrSymbol = strToRead(iIndex)
            If chrSymbol = "(" Then
                iNumberOfUnclosedBrackets = iNumberOfUnclosedBrackets + 1
            ElseIf chrSymbol = ")" Then
                iNumberOfUnclosedBrackets = iNumberOfUnclosedBrackets - 1
            End If
        End While
        If iNumberOfUnclosedBrackets > 0 Then
            Return -1
        Else
            Return iIndex
        End If
    End Function

    Private Function IdentifyCommand(ByRef strRCommand As String, clsRParameter As RParameter) As Char
        Dim clsRFunction As New RFunction
        Dim clsROperator As New ROperator
        Dim iIndexOfIdentifier As Integer
        Dim chrCandidateOperator As Char
        Dim iIndexOfMatchingBracket As Integer
        Dim lstListOfIdentifiers As Char() = {"(", "+", ":", "-", "*", "/"} 'Might need to deal with "$" one day...
        'Finding the first 
        iIndexOfIdentifier = strRCommand.IndexOfAny(lstListOfIdentifiers)
        If iIndexOfIdentifier <> -1 Then
            If strRCommand(iIndexOfIdentifier) = "(" Then
                iIndexOfMatchingBracket = FindMatchingBracket(strRCommand, iIndexOfIdentifier)
                chrCandidateOperator = strRCommand(iIndexOfIdentifier + 1)
                If iIndexOfMatchingBracket = strRCommand.Length - 1 Then
                    clsRFunction.SetRCommand(strRCommand.Substring(0, iIndexOfIdentifier - 1))
                    'The whole strRCommand is replaced by the string giving the parameters of the RFunction.
                    strRCommand = strRCommand.Substring(iIndexOfIdentifier + 1, strRCommand.Length - 2)
                    clsRParameter.SetArgumentFunction(clsRFunction) 'later SetArgument(clsRFunction, bIsFunction = TRUE) or something like that.
                    Return ","
                ElseIf Not lstListOfIdentifiers.Contains(chrCandidateOperator) Then
                    'message
                End If
            Else
                chrCandidateOperator = strRCommand(iIndexOfIdentifier)
            End If
            clsROperator.SetOperation(chrCandidateOperator)
            clsRParameter.SetArgumentOperator(clsROperator) 'later SetArgument(clsRFunction, bIsOperator = TRUE) or something like that.
            Return chrCandidateOperator
        Else
            'message
            Return Nothing
        End If
    End Function
    Private Sub AssimilateParameter(strRParameter As String, clsMotherCodeStructure As RCodeStructure)

        Dim lstRPNameAndValue As List(Of String)
        Dim clsNewRParameter As RParameter

        lstRPNameAndValue = SplitSmart(strRParameter, "=")
        'Have an overridable sub AddParameter in RCodeStructure... bIncludeParam name would be ignored when in operator case for instance.
        If lstRPNameAndValue.Count = 2 Then
            clsNewRParameter = ReadRCommand(lstRPNameAndValue(1))
            clsNewRParameter.SetArgumentName(lstRPNameAndValue(0))
            clsNewRParameter.bIncludeArgumentName = True

        ElseIf lstRPNameAndValue.Count = 1 Then
            clsNewRParameter = ReadRCommand(lstRPNameAndValue(1))
            clsNewRParameter.bIncludeArgumentName = False
        Else
            'message
        End If
        'clsMotherCodeStructure.AddParameter(clsNewRParameter) 'For when this will exist
    End Sub
End Class


