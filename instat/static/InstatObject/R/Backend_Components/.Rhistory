if (missing(weights))
return(stats::mad(x, constant = constant, na.rm = na.rm, low = low, high = high))
else{
Weighted.Desc.Stat::w.ad(x = x, mu = weights)
}
}
}
# Qn function
summary_Qn <- function(x, constant = 2.21914, finite.corr = missing(constant), na.rm = FALSE, na_type = "", ...) {
if(!na.rm && anyNA(x)) return(NA)
else {
if(na.rm && na_type != "" && !na_check(x, na_type = na_type, ...)) return(NA)
else{
x <- x[!is.na(x)]
return(robustbase::Qn(x, constant = constant, finite.corr = finite.corr))
}
}
}
# Sn function
summary_Sn <- function(x, constant = 1.1926, finite.corr = missing(constant), na.rm = FALSE, na_type = "", ...) {
if(!na.rm && anyNA(x)) return(NA)
else {
if(na.rm && na_type != "" && !na_check(x, na_type = na_type, ...)) return(NA)
else{
x <- x[!is.na(x)]
return(robustbase::Qn(x, constant = constant, finite.corr = finite.corr))
}
}
}
# cor function
summary_cor <- function(x, y, na.rm = FALSE, na_type = "", weights = "", method = c("pearson", "kendall", "spearman"), use = c( "everything", "all.obs", "complete.obs", "na.or.complete", "pairwise.complete.obs"), ...) {
if(na.rm && na_type != "" && !na_check(x, na_type = na_type, ...)) return(NA)
else{
if (missing(weights))
return(cor(x = x, y = y, use = use, method = method))
else{
weights::wtd.cor(x = x, y = y, weight = weights)[1]
}
}
}
# cov function
summary_cov <- function(x, y, na.rm = FALSE, weights = "", na_type = "", method = c("pearson", "kendall", "spearman"), use = c( "everything", "all.obs", "complete.obs", "na.or.complete", "pairwise.complete.obs"), ...) {
if(na.rm && na_type != "" && !na_check(x, na_type = na_type, ...)) return(NA)
else{
if (missing(weights)) {
return(cov(x = x, y = y, use = use, method = method))
}
if (length(weights) != length(x))
stop("'x' and 'weights' must have the same length")
if (na.rm) {
i <- !is.na(x) && !is.na(weights)
weights <- weights[i]
x <- x[i]
}
(sum(weights * x * y)/sum(weights)) - (Weighted.Desc.Stat::w.mean(x = x, mu = weights) * Weighted.Desc.Stat::w.mean(x = y, mu = weights))
}
}
# first function
summary_first <- function(x, order_by = NULL, ...) {
return(dplyr::first(x = x, order_by = order_by))
}
# last function
summary_last <- function(x, order_by = NULL, ...) {
return(dplyr::last(x = x, order_by = order_by))
}
# nth function
summary_nth <- function(x, nth_value, order_by = NULL, ...) {
return(dplyr::nth(x = x, n = nth_value, order_by = order_by))
}
# n_distinct function
summary_n_distinct<- function(x, na.rm = FALSE, ...) {
return(dplyr::n_distinct(x = x, na.rm = na.rm))
}
#Proportions functions
proportion_calc <- function(x, prop_test = "==", prop_value, As_percentage = FALSE, na.rm = FALSE, na_type = "", ... ){
if(na.rm && na_type != "" && !na_check(x, na_type = na_type, ...)) return(NA)
else{
if(!na.rm){
if(sum(is.na(x)) > 0) return(NA)
y <- x[eval(parse(text = paste("x", prop_value, sep = prop_test)))]
if(!As_percentage){
return(round(length(y)/length(x),digits = 2))
}
else {
return(round((length(y)/length(x)*100),digits = 2 ))
}
}
else {
remove.na <- na.omit(x)
y <- remove.na[eval(parse(text = paste("remove.na", prop_value, sep = prop_test)))]
if (!As_percentage){
return(round(length(y)/length(remove.na), digits = 2))
}
else{
return(round(length(y)/length(remove.na)*100, digits = 2 ))
}
}
}
}
#count function
count_calc <- function(x, count_test = "==", count_value, na.rm = FALSE, na_type = "", ...){
if(na.rm && na_type != "" && !na_check(x, na_type = na_type, ...)) return(NA)
else{
if (!na.rm){
if (sum(is.na(x)) > 0) return(NA)
return(length(x[eval(parse(text = paste("x", count_value, sep = count_test)))]))
}
else{
y <- na.omit(x)
return(length(y[eval(parse(text = paste("y", count_value, sep = count_test)))]))
}
}
}
#standard error of mean function
standard_error_mean <- function(x, na.rm = FALSE, na_type = "", ...){
if(na.rm && na_type != "" && !na_check(x, na_type = na_type, ...)) return(NA)
else{
if (!na.rm){
if(sum(is.na(x) > 0)) return(NA)
return(sd(x)/sqrt(length(x)))
}
else{
y <- na.omit(x)
return(sd(y)/sqrt(length(y)))
}
}
}
#Verification functions
#HydroGOF Package
#Coefficient of determination
coef_det <- function(x, y, na.rm = FALSE, na_type = "", ...){
if(na.rm && na_type != "" && !na_check(x, na_type = na_type, ...)) return(NA)
else{
return(hydroGOF::br2(sim = x, obs = y, na.rm = na.rm))
}
}
DataBook$set("public", "summary_table", function(data_name, columns_to_summarise = NULL, summaries, factors = c(), n_column_factors = 1, store_results = TRUE, drop = TRUE, na.rm = FALSE, summary_name = NA, include_margins = FALSE, return_output = TRUE, treat_columns_as_factor = FALSE, page_by = "default", as_html = TRUE, signif_fig = 2, na_display = "", na_level_display = "NA", weights = NULL, caption = NULL, result_names = NULL, percentage_type = "none", perc_total_columns = NULL, perc_total_factors = c(), perc_total_filter = NULL, perc_decimal = FALSE, margin_name = "(All)", additional_filter, ...) {
if(n_column_factors == 1 && length(factors) == 0) n_column_factors <- 0
if(n_column_factors > length(factors)) stop("n_column_factors must be <= number of factors specified.")
if(na_level_display == "") stop("na_level_display must be a non empty string")
if(n_column_factors > 0) {
column_factors <- factors[(length(factors) - n_column_factors + 1):length(factors)]
}
else column_factors <- c()
if(n_column_factors == length(factors)) row_factors <- c()
else row_factors <- setdiff(factors, column_factors)
#TODO change code so that it assumes row factors are first in factors list i.e. factors <- c(row_factors, column_factors)
factors <- c(column_factors, row_factors)
# removes "summary_" from beginning of summary function names so that display is nice
summaries_display <- sapply(summaries, function(x) ifelse(startsWith(x, "summary_"), substring(x, 9), x))
if(!is.null(page_by) && page_by == "default") {
if(length(columns_to_summarise) > 1 && length(summaries) > 1) {
page_by <- c("summaries", "variables")
}
else if(length(summaries) > 1) {
page_by <- "summaries"
}
else if(length(columns_to_summarise) > 1) {
page_by <- "variables"
}
else page_by <- c()
}
if(include_margins) {
#TODO fix these checks when we implement choice for page_by
# if(length(columns_to_summarise) > 1 && length(summaries) > 1 && !setequal(page_by, c("summaries", "variables"))) {
#   warning("Multiple summaries and variables with margins is currently only implemented through multiple pages. Overriding page_by to be c(summaries, variables)")
#   page_by <- c("summaries", "variables")
# }
# else if(length(summaries) > 1 && (length(page_by) == 0 || page_by != "summaries")) {
#   warning("Multiple summaries with margins is currently only implemented through multiple pages. Overriding page_by to be summaries")
#   page_by <- "summaries"
# }
# else if(length(columns_to_summarise) > 1 && (length(page_by) == 0 || page_by != "variables")) {
#   warning("Multiple variables with margins is currently only implemented through multiple pages. Overriding page_by to be variables")
#   page_by <- "variables"
# }
}
if(length(page_by) > 0) {
out <- list()
if(length(page_by) == 1 && page_by == "summaries") {
for(i in seq_along(summaries)) {
out[[paste(summaries_display[i], columns_to_summarise)]] <- self$summary_table(data_name = data_name, columns_to_summarise = columns_to_summarise, summaries = summaries[i], factors = factors, n_column_factors = n_column_factors, store_results = store_results, drop = drop, na.rm = na.rm, summary_name = summary_name, include_margins = include_margins, return_output = return_output, treat_columns_as_factor = treat_columns_as_factor, page_by = "default", as_html = as_html, weights = weights, na_display = na_display, result_names = result_names, percentage_type = percentage_type, perc_total_columns = perc_total_columns, perc_total_factors = perc_total_factors, perc_total_filter = perc_total_filter, perc_decimal = perc_decimal, margin_name = margin_name, additional_filter = additional_filter, perc_return_all = FALSE, ... = ...)
}
}
else if(length(page_by) == 1 && page_by == "variables") {
for(i in seq_along(columns_to_summarise)) {
out[[paste(summaries_display, columns_to_summarise[i])]] <- self$summary_table(data_name = data_name, columns_to_summarise = columns_to_summarise[i], summaries = summaries, factors = factors, n_column_factors = n_column_factors, store_results = store_results, drop = drop, na.rm = na.rm, summary_name = summary_name, include_margins = include_margins, return_output = return_output, treat_columns_as_factor = treat_columns_as_factor, page_by = "default", as_html = as_html, weights = weights, na_display = na_display, result_names = result_names, percentage_type = percentage_type, perc_total_columns = perc_total_columns, perc_total_factors = perc_total_factors, perc_total_filter = perc_total_filter, perc_decimal = perc_decimal, margin_name = margin_name, additional_filter = additional_filter, perc_return_all = FALSE, ... = ...)
}
}
else if(length(page_by) == 2  && all(page_by %in% c("variables", "summaries"))) {
for(i in seq_along(columns_to_summarise)) {
for(j in seq_along(summaries)) {
out[[paste(summaries_display[j], columns_to_summarise[i])]] <- self$summary_table(data_name = data_name, columns_to_summarise = columns_to_summarise[i], summaries = summaries[j], factors = factors, n_column_factors = n_column_factors, store_results = store_results, drop = drop, na.rm = na.rm, summary_name = summary_name, include_margins = include_margins, return_output = return_output, treat_columns_as_factor = treat_columns_as_factor, page_by = "default", as_html = as_html, weights = weights, na_display = na_display, result_names = result_names, percentage_type = percentage_type, perc_total_columns = perc_total_columns, perc_total_factors = perc_total_factors, perc_total_filter = perc_total_filter, perc_decimal = perc_decimal, margin_name = margin_name, additional_filter = additional_filter, perc_return_all = FALSE, ... = ...)
}
}
}
else if(all(page_by %in% factors)) {
levels_list <- lapply(page_by, function(x) levels(self$get_columns_from_data(data_name = data_name, col_names = x)))
levels_data_frame <- expand.grid(levels_list)
# temp fix for having empty levels in page_by factor
# currently only checks each factor level separately - could still crash if missing combinations
# TODO fix for general case
tmp_data <- self$get_data_frame(data_name)
levels_data_frame$filter <- TRUE
for(i in seq_along(page_by)) {
tab <- table(tmp_data[[page_by[[i]]]])
tab <- tab[tab > 0]
levels_data_frame$filter <- levels_data_frame$filter & (levels_data_frame[[paste0("Var", i)]] %in% names(tab))
}
levels_data_frame <- subset(levels_data_frame, filter)
levels_data_frame$filter <- NULL
for(j in 1:ncol(levels_data_frame)) {
levels_data_frame[,j] <- paste0(page_by[j], " == ", "'", levels_data_frame[,j], "'")
}
filter_expressions <- apply(levels_data_frame, 1, paste, collapse = " & ")
calculated_from <- as.list(page_by)
names(calculated_from) <- rep(data_name, length(page_by))
curr_factors <- setdiff(factors, page_by)
for(i in seq_along(filter_expressions)) {
filter_calc <- instat_calculation$new(type = "filter", function_exp = filter_expressions[i], calculated_from = calculated_from)
for(j in seq_along(summaries)) {
for(k in seq_along(columns_to_summarise)) {
out[[paste(filter_expressions[i], summaries_display[j], columns_to_summarise[k])]] <- self$summary_table(data_name = data_name, columns_to_summarise = columns_to_summarise[k], summaries = summaries[j], factors = curr_factors, n_column_factors = n_column_factors, store_results = store_results, drop = drop, na.rm = na.rm, summary_name = summary_name, include_margins = include_margins, return_output = return_output, treat_columns_as_factor = treat_columns_as_factor, page_by = "default", as_html = as_html, weights = weights, na_display = na_display, result_names = result_names, percentage_type = percentage_type, perc_total_columns = perc_total_columns, perc_total_factors = perc_total_factors, perc_total_filter = perc_total_filter, perc_decimal = perc_decimal, margin_name = margin_name, additional_filter = filter_calc, perc_return_all = FALSE, ... = ...)
}
}
}
}
else stop("page_by not recognised")
if(as_html) {
if(length(out) == 1 ) {
return(out[[1]])
}
else {
tabs <- htmlTable::concatHtmlTables(out, headers = "")
class(tabs) <- c("htmlTable", "character")
return(tabs)
}
}
else return(out)
}
else {
cell_values <- self$calculate_summary(data_name = data_name, columns_to_summarise = columns_to_summarise, summaries = summaries, factors = factors, store_results = store_results, drop = drop, na.rm = na.rm, return_output = TRUE, weights = weights, result_names = result_names, percentage_type = percentage_type, perc_total_columns = perc_total_columns, perc_total_factors = perc_total_factors, perc_total_filter = perc_total_filter, perc_decimal = perc_decimal, margin_name = margin_name, additional_filter = additional_filter, perc_return_all = FALSE)
for(i in seq_along(factors)) {
levels(cell_values[[i]]) <- c(levels(cell_values[[i]]), na_level_display)
cell_values[[i]][is.na(cell_values[[i]])] <- na_level_display
}
grps <- nrow(cell_values)
cell_values <- reshape2:::melt.data.frame(cell_values, id.vars = factors, variable.name = "Summary-Variable", value.name = "Value")
cell_values[["Variable"]] <- rep(rev(columns_to_summarise), each = nrow(cell_values)/length(columns_to_summarise))
cell_values[["Summary"]] <- rep(rev(summaries_display), each = grps, length.out = nrow(cell_values))
if(length(columns_to_summarise) > 1 || length(summaries) > 1) {
cell_values[["Summary-Variable"]] <- NULL
# TODO this relies on knowing order of output from calculate_summary
#      better method should be implemented not relying on this.
if(length(summaries) == 1) cell_values[["Summary"]] <- summaries_display
summary_factors <- c("Variable", "Summary")
if(!treat_columns_as_factor) {
if(length(summaries) > 1) {
cell_values[["Summary"]] <- paste(cell_values[["Summary"]], cell_values[["Variable"]], sep = "_")
}
else cell_values[["Summary"]] <- paste(summaries, cell_values[["Variable"]], sep = "_")
cell_values[["Variable"]] <- NULL
summary_factors <- "Summary"
}
}
else {
if(treat_columns_as_factor) {
summary_factors <- "Variable"
}
else {
summary_factors <- c()
cell_values[["Variable"]] <- NULL
cell_values[["Summary"]] <- NULL
}
}
if(length(column_factors) > 0) {
column_formula <- paste(column_factors, collapse = "+")
}
else column_formula <- "."
if(length(c(row_factors, summary_factors)) > 0) {
row_formula <- paste(c(row_factors, summary_factors), collapse = "+")
}
else row_formula <- "."
shaped_cell_values <- reshape2::dcast(formula = as.formula(paste(row_formula, "~", column_formula)), value.var = "Value", data = cell_values)
#This removes blank column caused by dcast having no row variables
if(length(c(row_factors, summary_factors)) == 0) shaped_cell_values[[1]] <- NULL
#Converts factor columns to character so we can relabel values if needed
for(i in seq_along(row_factors)) {
shaped_cell_values[[i]] <- as.character(shaped_cell_values[[i]])
}
if(include_margins && (length(row_factors) > 0 || length(column_factors) > 0)) {
margin_tables <- list()
power_sets <- rje::powerSet(factors)
# We could need last set if only have row or column factors
power_sets <- power_sets[-(c(length(power_sets)))]
for(facts in power_sets) {
if(length(facts) == 0) facts <- c()
margin_tables[[length(margin_tables) + 1]] <- self$calculate_summary(data_name = data_name, columns_to_summarise = columns_to_summarise, summaries = summaries, factors = facts, store_results = store_results, drop = drop, na.rm = na.rm, return_output = TRUE, weights = weights, result_names = result_names, percentage_type = percentage_type, perc_total_columns = perc_total_columns, perc_total_factors = perc_total_factors, perc_total_filter = perc_total_filter, perc_decimal = perc_decimal, margin_name = margin_name, additional_filter = additional_filter, perc_return_all = FALSE)
}
# Column Factor - add as row margin
if(length(row_factors) > 0) {
column_factor_margin <- margin_tables[[which(sapply(power_sets, function(x) setequal(column_factors, x)))]][[length(column_factors) + 1]]
new_row <- c(rep(NA, length(row_factors) + length(summary_factors)), column_factor_margin)
shaped_cell_values <- rbind(shaped_cell_values, new_row)
shaped_cell_values[nrow(shaped_cell_values), 1] <- margin_name
}
overall_value <- margin_tables[[1]][1,1]
if(length(column_factors) > 0) {
row_factor_margin <- margin_tables[[which(sapply(power_sets, function(x) setequal(row_factors, x)))]][[length(row_factors) + 1]]
# append the vector for the summary of interest in row_factor_margin with the overall_value
if(length(row_factors) > 0) {
overall_row_margin <- c(row_factor_margin, overall_value)
}
else overall_row_margin <- overall_value
# add into the unstacked dataset
shaped_cell_values[[margin_name]] <- overall_row_margin
}
align <- paste0(paste(rep("c", ncol(shaped_cell_values) - 1), collapse = ""), "|", "c")
}
else align <- paste(rep("c", ncol(shaped_cell_values)))
shaped_cell_values <- convert_to_character_matrix(shaped_cell_values, decimal_places = rep(signif_fig, ncol(shaped_cell_values)), na_display = na_display, check.names = FALSE)
if(return_output) {
if(is.null(caption)) {
caption <- ""
if(!missing(additional_filter)) caption <- paste(caption, additional_filter$function_exp, "|")
if(percentage_type != "none") {
if(perc_decimal) caption <- paste(caption, "Proportions")
else caption <- paste(caption, "Percentages")
if(percentage_type == "factors" && length(setdiff(factors, perc_total_factors)) > 0) caption <- paste0(caption, " (within ", paste(setdiff(factors, perc_total_factors), collapse = ", "), ")")
caption <- paste0(caption, ":")
}
if(length(columns_to_summarise) > 1 && length(summaries) > 1) {
caption <- paste(caption, "Summary of ", paste(columns_to_summarise, collapse = ","))
}
else if(length(columns_to_summarise) > 1) {
caption <- paste(caption, summaries, "of", paste(columns_to_summarise, collapse = ","))
}
else if(length(summaries) > 1) {
caption <- paste(caption, "Summary of", columns_to_summarise)
}
else {
caption <- paste(caption, summaries_display, columns_to_summarise)
}
caption <- gsub("_", ".", caption)
caption <- trimws(caption)
notes <- ""
if(length(row_factors) > 0) notes <- paste(notes, " Row Factors: ", paste0(row_factors, collapse = ", "))
if(length(column_factors) > 0) notes <- paste(notes, " Column Factors: ", paste0(column_factors, collapse = ", "))
if(length(weights) > 0) notes <- paste(notes, " Weights: ", paste0(weights, collapse = ", "))
}
if(as_html) {
if(length(column_factors) == 0) {
tab <- htmlTable::htmlTable(shaped_cell_values, caption = caption, total = include_margins, align = align, tfoot = notes, ... = ...)
class(tab) <- class(tab)[!class(tab) == "html"]
return(tab)
}
else {
spanner_data <- unique(cell_values[column_factors])
col_names <- c(row_factors, as.character(spanner_data[[length(spanner_data)]]))
if(include_margins) {
col_names <- c(col_names, margin_name)
}
names(shaped_cell_values) <- col_names
if(length(column_factors) == 1) {
cgroup <- c(rep("", length(row_factors)), column_factors)
n.cgroup <- c(rep(1, length(row_factors)), nrow(spanner_data))
}
else if(length(column_factors) > 1) {
# removes duplicate rows which exist when row factors present
spanner_data <- unique(cell_values[column_factors])
#TODO do this without having to call rle twice to improve efficiency
lengths <- lapply(spanner_data[-length(spanner_data)], function(x) rle(as.character(x))$lengths)
values <- lapply(spanner_data[-length(spanner_data)], function(x) rle(as.character(x))$values)
span_length <- max(sapply(values, length))
lengths <- sapply(lengths, function(x) c(rep(1, length(row_factors)), x, rep(NA, span_length - length(x))))
values <- sapply(values, function(x) c(rep("", length(row_factors)), x, rep(NA, span_length - length(x))))
cgroup <- t(values)
n.cgroup <- t(lengths)
}
css.cell <- ""
if(include_margins) {
if(is.matrix(cgroup)) {
cgroup <- cbind(cgroup, NA)
n.cgroup <- cbind(n.cgroup, NA)
for(i in 1:nrow(cgroup)) {
cgroup[i, which(is.na(cgroup[i, ]))[1]] <- ""
n.cgroup[i, which(is.na(n.cgroup[i, ]))[1]] <- 1
}
}
else {
cgroup[[length(cgroup) + 1]] <- ""
n.cgroup[[length(n.cgroup) + 1]] <- 1
}
css.cell <- matrix("", nrow = nrow(shaped_cell_values), ncol = ncol(shaped_cell_values))
if(length(column_factors) > 0) css.cell[ , ncol(css.cell)] <- "font-weight: 900;"
if(length(row_factors) > 0) css.cell[nrow(css.cell), ] <- "border-top: 1px solid #BEBEBE; font-weight: 900;"
}
tab <- htmlTable::htmlTable(shaped_cell_values, caption = caption, total = FALSE, align = align, tfoot = notes, cgroup = cgroup, n.cgroup = n.cgroup, css.cell = css.cell, ... = ...)
class(tab) <- class(tab)[!class(tab) == "html"]
return(tab)
}
}
else return(shaped_cell_values)
#return(stargazer::stargazer(shaped_cell_values, type = "html", summary = FALSE, rownames = FALSE, title = caption, notes = notes, ... = ...))
}
}
}
)
#Coefficient of determination
coef_det <- function(x, y, na.rm = FALSE, na_type = "", ...){
if(na.rm && na_type != "" && !na_check(x, na_type = na_type, ...)) return(NA)
else{
return(hydroGOF::br2(sim = x, obs = y, na.rm = na.rm))
}
}
coef_det(x,y, na.rm = T, na_type = "n", na_max_n = 1)
coef_det(x,y, na.rm = T, na_type = "n", na_max_n = 2)
x
y
coef_det(x,y, na.rm = T, na_type = "n", na_max_n = 2)
hyro
?hydroGOF::cp()
coef_det(x = c(NA,NA), y = c(NA,NA))
coef_det(x = c(NA,2), y = c(NA,NA))
coef_det(x = c(NA,2), y = c(NA,NA), na.rm = T)
coef_det(x = c(NA,2), y = c(NA,5), na.rm = T)
coef_det(x = c(NA,NA), y = c(NA,5), na.rm = T)
coef_det(x = c(1,NA), y = c(NA,5), na.rm = T)
coef_det(x = c(NA,NA), y = c(NA,5))
coef_det(x = c(NA,4), y = c(NA,5))
coef_det(x = c(NA,4), y = c(NA,5), na.rm = T)
coef_det(x = c(NA,NA), y = c(NA,5), na.rm = T)
coef_det(x = c(NA,NA), y = c(NA,5))
coef_det(x = c(NA,NA), y = c(NA,5))
coef_det(x = c(NA,NA), y = c(NA,NA))
coef_det(x = c(NA,2), y = c(NA,NA))
all(x)
x
is.na(x)
identical(is.na(x))
unique(is.na(x))
unique(is.na(x))==T
unique(is.na(x))
unique(is.na(x))
is.na(x)
length(is.na(x))
length(x[is.na(x)])
length(x[is.na(x)])==length(x)
#Coefficient of determination
coef_det <- function(x, y, na.rm = FALSE, na_type = "", ...){
if(na.rm && na_type != "" && !na_check(x, na_type = na_type, ...)) return(NA)
else{
if(length(x[is.na(x)])==length(x)||length(y[is.na(y)])==length(y)) return(NA)
return(hydroGOF::br2(sim = x, obs = y, na.rm = na.rm))
}
}
coef_det(x = c(NA,2), y = c(NA,NA))
coef_det(x = c(NA,2), y = c(NA,4))
coef_det(x = c(NA,2), y = c(NA,4), na.rm = T)
coef_det(x = c(NA,2), y = c(NA,4), na.rm = T)
coef_det(x = c(NA,2), y = c(NA,NA), na.rm = T)
coef_det(x = c(NA,2), y = c(NA,NA))
br2(x = c(NA,2), y = c(NA,NA))
br2(c(NA,2),c(NA,NA))
cp(c(NA,2),c(NA,NA))
#Coefficient of persistence
coef_pers <- function(x, y, na.rm = FALSE, na_type = "", ...){
if(na.rm && na_type != "" && !na_check(x, na_type = na_type, ...)) return(NA)
else{
if(length(x[is.na(x)])==length(x)||length(y[is.na(y)])==length(y)) return(NA)
return(hydroGOF::cp(sim = x, obs = y, na.rm = na.rm))
}
}
coef_pers(x = c(NA,2), y = c(NA,4))
coef_pers(x = c(NA,2), y = c(NA,4))
coef_pers(x = c(NA,2), y = c(NA,4))
cp(c(NA,2),c(NA,NA))
cp(c(NA,2),c(NA,8))
cp(c(7,2),c(NA,8))
cp(c(7,2),c(3,8))
cp(c(7,2),c(3,8))
cp(c(7,2),c(NA,8))
#Coefficient of persistence
coef_pers <- function(x, y, na.rm = FALSE, na_type = "", ...){
if(na.rm && na_type != "" && !na_check(x, na_type = na_type, ...)) return(NA)
else{
if(any(is.na(x))) return(NA)
return(hydroGOF::cp(sim = x, obs = y, na.rm = na.rm))
}
}
coef_pers(x = c(NA,2), y = c(NA,4))
coef_pers(x = c(1,2), y = c(5,4))
cp(c(7,2),c(NA,8))
cp(c(7,2),c(NA,8))
#Coefficient of persistence
coef_pers <- function(x, y, na.rm = FALSE, na_type = "", ...){
if(na.rm && na_type != "" && !na_check(x, na_type = na_type, ...)) return(NA)
else{
if(any(is.na(x))) return(NA)
return(hydroGOF::cp(sim = x, obs = y, na.rm = na.rm))
}
}
coef_pers(x = c(NA,2), y = c(NA,4))
coef_pers(x = c(1,2), y = c(3,4))
coef_pers(x = mtcars$mpg, y = c(3,4))
coef_pers(x = mtcars$mpg, y = mtcars$cyl
)
coef_pers(x = mtcars$mpg, y = mtcars$cyl)
x <- 1:10
factor(x)
f <- factor(x)
class(f)
